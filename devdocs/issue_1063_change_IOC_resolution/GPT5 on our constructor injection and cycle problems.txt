Our WinUI 3 app is using Community Toolkit MVVM dependency injection. Our pages tie to their corresponding viewmodels in their code behind, like this bit of WebPage.xaml.cs: 
public sealed partial class WebPage : BindablePage
{
    WebViewModel WebVM = Ioc.Default.GetRequiredService<WebViewModel>();
    private LogService Logger = Ioc.Default.GetRequiredService<LogService>();

    public WebPage()
    {
        InitializeComponent();
        DataContext = WebVM;
        WebVM.Refresh = Refresh;
        WebVM.GoForward = GoForward;
        WebVM.GoBack = GoBack;
    }

The parameterless constructor for the viewmodel looks like this:
 public WebViewModel() : this(
     Ioc.Default.GetRequiredService<Windowing>(),
     Ioc.Default.GetRequiredService<AppState>(),
     Ioc.Default.GetRequiredService<LogService>(),
     Ioc.Default.GetRequiredService<PreferenceService>())
 {
 }

But I'm trying to go to true DI by having the constructor inject the services and have a second constructor:

 public WebViewModel(Windowing window, AppState appState, LogService logger, PreferenceService preferenceService)
 {
.,,,

How can resolve this 'need' to use the parameterless constructor?  
     _window = window;
     _appState = appState;
     _logger = logger;
     _preferenceService = preferenceService;
        
ChatGPT said:
Thought for 29s

Short answer: you don’t need a parameterless constructor on the viewmodel at all. Register the VM and its deps in the DI container, delete the parameterless ctor, and keep resolving it via Ioc.Default.GetRequiredService<WebViewModel>(). The container will call your injecting ctor.

Step-by-step

Register services & VM

// App startup / Host builder
services.AddSingleton<Windowing>();
services.AddSingleton<AppState>();
services.AddSingleton<LogService>();
services.AddSingleton<PreferenceService>();

services.AddTransient<WebViewModel>(); // <-- VM via DI


Remove the parameterless VM ctor

public sealed class WebViewModel
{
    private readonly Windowing _window;
    private readonly AppState _appState;
    private readonly LogService _logger;
    private readonly PreferenceService _preferenceService;

    public WebViewModel(
        Windowing window,
        AppState appState,
        LogService logger,
        PreferenceService preferenceService)
    {
        _window = window;
        _appState = appState;
        _logger = logger;
        _preferenceService = preferenceService;
    }
}


Page code-behind (no changes needed)

public sealed partial class WebPage : BindablePage
{
    private readonly WebViewModel WebVM = Ioc.Default.GetRequiredService<WebViewModel>();
    private readonly LogService Logger = Ioc.Default.GetRequiredService<LogService>();

    public WebPage()
    {
        InitializeComponent();
        DataContext = WebVM;
        WebVM.Refresh = Refresh;
        WebVM.GoForward = GoForward;
        WebVM.GoBack = GoBack;
    }
}


Because you’re resolving the VM from the container, the framework uses the injecting ctor.

Design-time XAML (optional, avoids needing a paramless VM ctor for the designer)

<Page
    ...
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:vm="using:YourApp.ViewModels"
    d:DataContext="{d:DesignInstance Type=vm:WebViewModel, IsDesignTimeCreatable=False}">

If you also want constructor injection for Pages

WinUI 3 creates pages with Activator.CreateInstance, so pages normally need a paramless ctor. To inject into pages, create them via DI and navigate with a service:

public interface INavigationService { void Navigate<TPage>() where TPage : Page; }

public sealed class NavigationService : INavigationService
{
    private readonly IServiceProvider _sp;
    private readonly Frame _frame;
    public NavigationService(IServiceProvider sp, Frame frame)
    {
        _sp = sp; _frame = frame;
    }
    public void Navigate<TPage>() where TPage : Page
    {
        var page = ActivatorUtilities.CreateInstance<TPage>(_sp);
        _frame.Navigate(page.GetType()); // WinUI needs a Type; use a PageFactory instead:
        // Alternative: host a custom Frame that supports instance navigation, or cache the created page and use NavigateToType with parameter to retrieve from DI.
    }
}


But for your current pattern (page resolves VM from DI), simply drop the parameterless VM constructor and you’re done.

You said:
With the constructor injection, we can see dependency cycles, which weren't visible with the Ioc.Default.GetService type of calls. In most cases these seem to be SRP violations- the dependency is only for a particular property or the like. What's the best way to fix these?
ChatGPT said:
Thought for 12s

You’re right: once you switch to ctor-injection, hidden SRP leaks show up as cycles (A⇄B). The fix is to reduce responsibilities and invert communication. Use this checklist:

1) Extract the “sliver” actually needed

If A only needs a property/method of B, don’t inject B. Extract a narrow interface and inject that instead.

public interface IReadOnlySession
{
    User? CurrentUser { get; }
}
public sealed class AppState : IReadOnlySession { ... }

// Before: public WebViewModel(AppState appState, ...)
public WebViewModel(IReadOnlySession session /* ... */) { ... }


This often dissolves A⇄B because B no longer depends on A’s full type (and vice versa).

2) Split services by responsibility

If A needs B for two unrelated reasons, carve B into B1 + B2.

services.AddSingleton<IAuthState, AuthState>();
services.AddSingleton<INavigationContext, NavigationContext>();


Inject only the one you need.

3) Invert direct calls with a mediator/event bus

Replace “B calls A” with publish/subscribe. CommunityToolkit’s WeakReferenceMessenger works well.

public sealed record UrlChangedMessage(string Url);

public sealed class BrowserService
{
    private readonly IMessenger _m;
    public BrowserService(IMessenger m) => _m = m;

    public void OnUrlChanged(string url) => _m.Send(new UrlChangedMessage(url));
}

public sealed class WebViewModel : IRecipient<UrlChangedMessage>
{
    public WebViewModel(IMessenger m /* ... */) => m.Register(this);
    public void Receive(UrlChangedMessage msg) { CurrentUrl = msg.Url; }
}


Now neither side holds a hard dependency on the other.

4) Use factories/providers for on-demand creation

If A needs to create B (or vice versa), inject a factory instead of the concrete type.

public interface IWebVmFactory { WebViewModel Create(); }

public sealed class WebVmFactory : IWebVmFactory
{
    private readonly IServiceProvider _sp;
    public WebVmFactory(IServiceProvider sp) => _sp = sp;
    public WebViewModel Create() => _sp.GetRequiredService<WebViewModel>();
}

// Registration
services.AddTransient<WebViewModel>();
services.AddSingleton<IWebVmFactory, WebVmFactory>();

// Usage (e.g., in NavigationService)
public NavigationService(IWebVmFactory vmFactory) { ... }


Lightweight option: inject Func<WebViewModel> or Func<T> delegates.

5) Prefer data/commands over service references

If you only need a one-off value or action, pass it as a parameter/delegate, not a service.

public sealed class SaveCommand : ICommand
{
    private readonly Func<Task> _save;
    public SaveCommand(Func<Task> save) => _save = save;
    public async void Execute(object? _) => await _save();
}
// VM ctor: new SaveCommand(() => _docService.SaveAsync(CurrentDoc))

6) Use Lazy<T> for rare, heavy, or cyclic-ish cases

When both sides must reference each other but only one side needs the other late:

public WebViewModel(Lazy<InspectorViewModel> inspector /* ... */) { _inspector = inspector; }
// Access only when needed: _inspector.Value.ShowFor(item);


This often breaks construction-time cycles.

7) Keep lifetimes sensible

Most VMs: Transient.

App-wide state/logging/config: Singleton.

Avoid singletons that hold references to VMs (memory leaks & cycles).

8) Don’t inject VMs into services

Services should be UI-agnostic. If a service needs to notify UI, use messages/events (see #3).

Quick recipe to fix a concrete cycle

Identify the minimal need (property/method/event).

Extract a read-only or role-specific interface for that need (#1/#2).

If the other direction is “notifications”, switch it to messages/events (#3).

If creation causes the cycle, introduce a factory or Func<T> (#4).

Only if necessary, apply Lazy<T> to defer (#6).

Apply these and you’ll eliminate nearly all ctor-time cycles while tightening SRP.

You said:
For Identify the minimal need (property/method/event), is there a reliable way to identify them?
ChatGPT said:
Thought for 17s

Yes—use a mechanical “squeeze” plus tests. Here’s a reliable, repeatable way:

1) Compile-time “squeeze” (guarantees minimal surface)

Goal: derive the smallest interface that still compiles.

Procedure (per dependency):

Create a blank role interface, e.g. IReadOnlyAppState { }.

Change the constructor to depend on that interface, and introduce an adapter over the real service.

public interface IReadOnlyAppState { /* start empty */ }

public sealed class AppStateAdapter : IReadOnlyAppState
{
    private readonly AppState _inner;
    public AppStateAdapter(AppState inner) => _inner = inner;
    // add members here only when compiler errors demand them
}

// Registration
services.AddSingleton<AppState>();
services.AddTransient<IReadOnlyAppState>(sp => new AppStateAdapter(sp.GetRequiredService<AppState>()));


Build. For each compiler error (missing member), add exactly that member to the interface + adapter:

If you only read data: expose get-only properties.

If you only command: expose methods returning Task/bool, no extra types.

If you only observe: expose events (or an IObservable<T>).

Repeat until it compiles. The interface is now provably minimal for the current usage.

This is fast and objective; the compiler tells you what’s needed.

2) Add a strict test to keep it minimal

Prevent interface bloat later.

Strict mocks (Moq/NSubstitute) + VerifyNoOtherCalls:

var appState = new Mock<IReadOnlyAppState>(MockBehavior.Strict);
// Setup only what WebViewModel actually uses
appState.SetupGet(a => a.CurrentUser).Returns(user);

var vm = new WebViewModel(appState.Object /* ... */);

// After exercising vm:
appState.VerifyNoOtherCalls();


This fails if someone adds new calls (or widens the interface) accidentally.

3) (Optional) Runtime “spy” to validate real usage

For confidence across scenarios, log the actual members used.

Wrap the dependency with a Castle DynamicProxy interceptor (or a hand-written proxy) that logs which members are touched during UI flows/tests. Union the results and compare to the interface; remove unused members.

4) Heuristics that fall out of the process

If you only ever read: make IReadOnlyX with get-only props.

If you only ever write/trigger: expose commands/events, not state.

If a dependency adds many required members for unrelated reasons, split it (SRP) and inject only the relevant role.

If a cycle remains purely for creation, switch to Func<T>/factory for that edge.

5) Team guardrails

Add an Arch test (e.g., NetArchTest) that forbids ViewModels from depending on concrete services except via role interfaces.

Code review rule: any new dependency must start as an empty role interface and be grown by compiler errors (step #1).

This combo—compile-time squeeze + strict tests—gives you a deterministic, low-friction way to find (and keep) the true minimal need.

You said:
I've read this squeeze several times but it's apparently above my paygrade. Can you explain it more simply?
ChatGPT said:

Got it — let’s strip this down to something simple and practical.

When I said “squeeze,” I just meant: only take what the class actually needs, nothing more.

How to do it, in plain steps:

Look at what your class calls on the dependency.

Does it only read a property? Then all you need is a read-only property.

Does it only call one method? Then all you need is that method.

Does it only listen for an event? Then all you need is that event.

Make a tiny interface that contains just those things.

public interface IReadOnlyAppState
{
    User? CurrentUser { get; }
}


Have the bigger service implement that interface.

public class AppState : IReadOnlyAppState
{
    public User? CurrentUser { get; private set; }
    // ... other unrelated stuff stays here ...
}


Inject the small interface instead of the whole big service.

public WebViewModel(IReadOnlyAppState appState)
{
    _appState = appState;
}


Now your ViewModel is only coupled to what it actually uses, and you often break the cycle.

Example with a cycle

Before:
WebViewModel needs AppState and AppState also references WebViewModel → cycle.

After:
WebViewModel depends on IReadOnlyAppState (just one property).
AppState no longer needs the whole VM, maybe it just raises an event → cycle gone.

👉 The “squeeze” is just:
What’s the smallest slice of that dependency I truly need? Put that in an interface, and inject only that.

Do you want me to take one of your actual dependencies (AppState, Windowing, etc.) and show you exactly how to “squeeze” it down into a minimal interface?